name: Build, Test, Publish

on:
  pull_request:
  push:
    branches: ["main"]
  schedule:
    - cron: "0 0 * * 1-5"
  workflow_dispatch:

permissions:
  contents: read

jobs:

  create:
    runs-on: ubuntu-22.04
    strategy:
      fail-fast: false
      matrix:
        builder: ["buildpacks-20", "builder-classic-22", "builder-22"]
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Install Pack CLI
        uses: buildpacks/github-actions/setup-pack@v5.4.0
      - name: Create builder image
        run: pack builder create ${{ matrix.builder }} --config ${{ matrix.builder }}/builder.toml --pull-policy always
      # We export the run image too (and not just the generated builder image), since it adds virtually
      # no size to the archive (since the layers are mostly duplicates), and it ends up being quicker
      # than docker pulling the run image in the jobs that perform the pack build.
      # We manually compress the archive rather than relying upon actions/cache's compression, since
      # it ends up being faster both in this job and also later when the images are consumed.
      - name: Export Docker images from the Docker daemon
        env:
          BUILDER: ${{ matrix.builder }}
        run: docker save ${{ matrix.builder }} heroku/heroku:${BUILDER##*-}-cnb | zstd -T0 --long=31 -o images.tar.zst
      # We use a cache here rather than artifacts because it's 4x faster and we
      # don't need the builder archive outside of this workflow run anyway.
      - name: Save Docker images to the cache
        uses: actions/cache/save@v3
        with:
          key: ${{ github.run_id}}-${{ matrix.builder }}
          path: images.tar.zst

  test-guides:
    runs-on: ubuntu-22.04
    needs: create
    strategy:
      fail-fast: false
      matrix:
        builder: ["buildpacks-20", "builder-classic-22", "builder-22"]
        language: ["go", "gradle", "java", "node-js", "php", "python", "ruby", "scala", "typescript"]
        include:
          - builder: builder-classic-22
            language: clojure
    steps:
      - name: Checkout getting started guide
        uses: actions/checkout@v3
        with:
          ref: main
          repository: heroku/${{ matrix.language }}-getting-started.git
      - name: Install Pack CLI
        uses: buildpacks/github-actions/setup-pack@v5.4.0
      - name: Restore Docker images from the cache
        uses: actions/cache/restore@v3
        with:
          fail-on-cache-miss: true
          key: ${{ github.run_id}}-${{ matrix.builder }}
          path: images.tar.zst
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 1
      - name: Load Docker images into the Docker daemon
        run: zstd -dc --long=31 images.tar.zst | docker load
      - name: Build getting started guide image
        run: pack build getting-started --builder ${{ matrix.builder }} --trust-builder --pull-policy never
      - name: Start getting started guide image
        run: docker run --name getting-started --detach -p 8080:8080 --env PORT=8080 getting-started
      - name: Test getting started web server response
        run: |
          if curl -sSf --retry 10 --retry-delay 1 --retry-all-errors --connect-timeout 3 http://localhost:8080 -o response.txt; then
            echo "Successful response from server"
          else
            echo "Server did not respond successfully"
            docker logs getting-started
            [[ -f response.txt ]] && cat response.txt
            exit 1
          fi

  test-functions:
    runs-on: ubuntu-22.04
    needs: create
    strategy:
      fail-fast: false
      matrix:
        builder: ["builder-22"]
        language: ["java", "javascript", "typescript"]
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Install Pack CLI
        uses: buildpacks/github-actions/setup-pack@v5.4.0
      - name: Restore Docker images from the cache
        uses: actions/cache/restore@v3
        with:
          fail-on-cache-miss: true
          key: ${{ github.run_id}}-${{ matrix.builder }}
          path: images.tar.zst
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 1
      - name: Load Docker images into the Docker daemon
        run: zstd -dc --long=31 images.tar.zst | docker load
      - name: Build example function image
        run: pack build example-function --path examples/functions/${{ matrix.language }} --builder ${{ matrix.builder }} --trust-builder --pull-policy never
      - name: Start example function image
        run: docker run --name example-function --detach -p 8080:8080 --env PORT=8080 example-function
      - name: Test example function web server response
        run: |
          if curl -sSf --retry 10 --retry-delay 1 --retry-all-errors --connect-timeout 3 -X POST -H 'x-health-check: true' http://localhost:8080 -o response.txt; then
            echo "Successful response from function"
          else
            echo "Function did not respond successfully"
            docker logs example-function
            [[ -f response.txt ]] && cat response.txt
            exit 1
          fi

  publish:
    runs-on: ubuntu-22.04
    if: success() && github.ref == 'refs/heads/main'
    needs:
      - test-guides
      - test-functions
    strategy:
      fail-fast: false
      matrix:
        include:
          - builder: buildpacks-20
            tag_public: heroku/buildpacks:20
            tag_private: heroku-20:builder
          - builder: builder-classic-22
            tag_public: heroku/builder-classic:22
          - builder: builder-22
            tag_public: heroku/builder:22
            tag_private: heroku-22:builder
    steps:
      - name: Restore Docker images from the cache
        uses: actions/cache/restore@v3
        with:
          fail-on-cache-miss: true
          key: ${{ github.run_id}}-${{ matrix.builder }}
          path: images.tar.zst
        env:
          SEGMENT_DOWNLOAD_TIMEOUT_MINS: 1
      - name: Load Docker images into the Docker daemon
        run: zstd -dc --long=31 images.tar.zst | docker load
      - name: Log into Docker Hub
        run: echo "${{ secrets.DOCKER_HUB_TOKEN }}" | docker login -u ${{ secrets.DOCKER_HUB_USER }} --password-stdin
      - name: Log into additional registry
        run: |
          export REGISTRY_TOKEN=$(curl -f -X POST ${{ secrets.SERVICE_TOKEN_ENDPOINT }} -d "{\"username\":\"${{ secrets.SERVICE_TOKEN_USER_NAME }}\", \"password\":\"${{ secrets.SERVICE_TOKEN_PASSWORD }}\"}" -s --retry 3 | jq -r ".raw_id_token")
          echo "$REGISTRY_TOKEN" | docker login ${{ secrets.REGISTRY_HOST }} -u "${{ secrets.REGISTRY_USER }}" --password-stdin
      - name: Tag builder and push to registries
        run: |
          if [[ -n "${{ matrix.tag_private }}" ]]; then
            export TAG_PRIVATE="${{ secrets.REGISTRY_HOST }}/s/${{ secrets.SERVICE_TOKEN_USER_NAME }}/${{ matrix.tag_private }}"
          fi
          export TAGS=($TAG_PRIVATE ${{ matrix.tag_public }})
          for tag in ${TAGS[@]}; do
            echo "Pushing $tag"
            docker tag ${{ matrix.builder }} $tag
            docker push $tag
          done
